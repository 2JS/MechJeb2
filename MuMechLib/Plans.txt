* Convert to PartModule
DONE    - Turn MechJebCore into its own PartModule
        - Can we do all necessary cleanup in OnDestroy?
            Should work, though there are times that strong references are kept around and the part becomes a zombie. We should move cleanup to it's own function and call it from OnDestroy, register on Vessel.OnJustAboutToBeDestroyed and wherever else looks good.
        - Turn the classes that handle part animations into separate PartModules

* Split up MechJebCore?
  Core has the following parts:
        - GUI
DONE    - ComputerModule callbacks
DONE    - stuff that figures out which MechJebCore is controlling the vessel
DONE    - attitude controller
DONE    - thrust controller
DONE    - warp controller
DONE    - autostaging controller
        - settings saving

* Split existing modules into ComputerModules and DisplayModules

* Explicit support for third-party ComputerModules and DisplayModules?

* New settings system? The old one works reasonably now, but N3X15 coded some functions to work with setting a bit better, may be worth trying... And we could work something in for Vessel-specific saving too.
    - Does N3X15's PluginConfiguration actually have any benefits over our SettingsManager?
    - for vessel-specifc info the OnSave/OnLoad ConfigNode system is worth trying; it 
	  should save any vessel-specific info we have directly to the SFS
	

* New GUI
    - Protractor-like icon?
        Look for a 2D artist
    - Choose either a new GUIStyle or create one from scratch.
    - Customizable info-windows: make lists with all the variables/titles, and allow the user to build his own windows

* Add a system for DisplayModules to easily have in-VAB GUI windows
    - Maybe just a drawEditorGUI() in addition to drawGUI()?
    - Figure out good way to make sure settings are saved if they're modified in the editor
      (OnUpdate/OnFixedUpdate don't get called there, and that's where MechJebCore used to save settings)
        We should move to Update/FixedUpdate on the core (which runs independent from the Part being active), to avoid all kinds of problems

DONE * Change (most) orbital operations to create maneuver nodes
        - Split orbital operations into:
DONE        - A calculation class that computes required burns for operations
                - This class can be reused elsewhere, e.g. by the landing autopilot
            - A ComputerModule that performs operations under autopilot
            - A DisplayModule that creates maneuver nodes for operations

* Make the Core control more streamlined, and add RCS translation control

DONE * Create PartExtensions and VesselExtensions classes

* Allow a "no-autopilot" mode (enabled/disabled via part.cfg?)
        - Requires separating all autopilot functionality from information displays
            - Split Ascent Stats into its own ComputerModule
            - Split landing AP simulations from autopilot
DONE        - Split orbital operations dV calculations from autopilot

* Move everything in ARUtils somewhere else:
DONE    - Move staging functions into staging controller
        - Move vessel-related functions into VesselState and VesselExtensions
        - Move part-related functions into PartExtensions
        - Move random utilities into MuUtils

* Finally figure out multithreading to offload the FuelFlowAnalyzer and landing autopilot simulations to their own threads
        - Then make separate ComputerModules just to do the simulations. Other classes can
          turn these ComputerModules on or off. When they're on they periodically rerun the simulations
          and update their results, which other classes can read off.
            Check out the old MechJebModuleAscension.cs/optimalAscent.cs for a threaded implementation of a module, it works well enough (the threading, the calculator isn't very good XD)

DONE * Add a check that will throttle down to prevent overheats during any sort of autopilot operation
        - Moved ascent AP code into thrust controller

* Allow auto-staging during any sort of autopilot operation
        - a toggle like in the ascent AP, but in the main menu?
            We need an options screen, but we may want to add the auto-staging thing in multiple places so the user can disable it as needed? Maybe having some options directly in the menu may be indeed an option.

* Move Core (ThrustController) landing function into landing autopilot, since nothing else uses it?

* Have a "factory restore" button for all settings? (that just deletes the settings file?)

* Split ascent AP path into a separate class & a separate display module to edit ascent paths
        - Then add a type of ascent path that evalutes a user-entered C# or Lua expression
		- Add a Computer/DisplayModule to provide ascent path guidance on the navball, but no autopilot